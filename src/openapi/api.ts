/* tslint:disable */
/* eslint-disable */
/**
 * EarthScore B2C API
 * Your description
 *
 * The version of the OpenAPI document: v1
 * Contact: contact@snippets.local
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountsClientsList200Response
 */
export interface AccountsClientsList200Response {
    /**
     * 
     * @type {number}
     * @memberof AccountsClientsList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof AccountsClientsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountsClientsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Client>}
     * @memberof AccountsClientsList200Response
     */
    'results': Array<Client>;
}
/**
 * 
 * @export
 * @interface AccountsUsersList200Response
 */
export interface AccountsUsersList200Response {
    /**
     * 
     * @type {number}
     * @memberof AccountsUsersList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof AccountsUsersList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountsUsersList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof AccountsUsersList200Response
     */
    'results': Array<User>;
}
/**
 * 
 * @export
 * @interface Answer
 */
export interface Answer {
    /**
     * 
     * @type {number}
     * @memberof Answer
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Answer
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof Answer
     */
    'order'?: number;
}
/**
 * 
 * @export
 * @interface AnswerCreate
 */
export interface AnswerCreate {
    /**
     * 
     * @type {string}
     * @memberof AnswerCreate
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof AnswerCreate
     */
    'question': number;
}
/**
 * 
 * @export
 * @interface AnswerList
 */
export interface AnswerList {
    /**
     * 
     * @type {number}
     * @memberof AnswerList
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AnswerList
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof AnswerList
     */
    'order'?: number;
    /**
     * 
     * @type {number}
     * @memberof AnswerList
     */
    'question': number;
}
/**
 * 
 * @export
 * @interface AnswerRespond
 */
export interface AnswerRespond {
    /**
     * 
     * @type {number}
     * @memberof AnswerRespond
     */
    'answer': number;
    /**
     * 
     * @type {number}
     * @memberof AnswerRespond
     */
    'question': number;
    /**
     * 
     * @type {string}
     * @memberof AnswerRespond
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface AnswerResponds
 */
export interface AnswerResponds {
    /**
     * 
     * @type {number}
     * @memberof AnswerResponds
     */
    'questionnaire': number;
    /**
     * 
     * @type {Array<AnswerRespond>}
     * @memberof AnswerResponds
     */
    'responds': Array<AnswerRespond>;
}
/**
 * 
 * @export
 * @interface AnswerUpdate
 */
export interface AnswerUpdate {
    /**
     * 
     * @type {string}
     * @memberof AnswerUpdate
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof AnswerUpdate
     */
    'order'?: number;
}
/**
 * 
 * @export
 * @interface Campaign
 */
export interface Campaign {
    /**
     * 
     * @type {number}
     * @memberof Campaign
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'status'?: CampaignStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Campaign
     */
    'questionnaire': number;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'end_date': string;
}

export const CampaignStatusEnum = {
    Draft: 'draft',
    InQueue: 'in_queue',
    Running: 'running',
    Finished: 'finished'
} as const;

export type CampaignStatusEnum = typeof CampaignStatusEnum[keyof typeof CampaignStatusEnum];

/**
 * 
 * @export
 * @interface CampaignCreate
 */
export interface CampaignCreate {
    /**
     * 
     * @type {string}
     * @memberof CampaignCreate
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof CampaignCreate
     */
    'questionnaire': number;
    /**
     * 
     * @type {string}
     * @memberof CampaignCreate
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof CampaignCreate
     */
    'end_date': string;
    /**
     * 
     * @type {number}
     * @memberof CampaignCreate
     */
    'client': number;
}
/**
 * 
 * @export
 * @interface CampaignList
 */
export interface CampaignList {
    /**
     * 
     * @type {number}
     * @memberof CampaignList
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CampaignList
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CampaignList
     */
    'status'?: CampaignListStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof CampaignList
     */
    'questionnaire': number;
    /**
     * 
     * @type {string}
     * @memberof CampaignList
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof CampaignList
     */
    'end_date': string;
}

export const CampaignListStatusEnum = {
    Draft: 'draft',
    InQueue: 'in_queue',
    Running: 'running',
    Finished: 'finished'
} as const;

export type CampaignListStatusEnum = typeof CampaignListStatusEnum[keyof typeof CampaignListStatusEnum];

/**
 * 
 * @export
 * @interface CampaignUpdate
 */
export interface CampaignUpdate {
    /**
     * 
     * @type {string}
     * @memberof CampaignUpdate
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ChangePassword
 */
export interface ChangePassword {
    /**
     * 
     * @type {string}
     * @memberof ChangePassword
     */
    'old_password': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePassword
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePassword
     */
    'password2': string;
}
/**
 * 
 * @export
 * @interface ChangePasswordError
 */
export interface ChangePasswordError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ChangePasswordError
     */
    'old_password': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChangePasswordError
     */
    'password': Array<string>;
}
/**
 * 
 * @export
 * @interface Client
 */
export interface Client {
    /**
     * 
     * @type {number}
     * @memberof Client
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'avatar_url'?: string;
}
/**
 * 
 * @export
 * @interface ClimateMetrics
 */
export interface ClimateMetrics {
    /**
     * 
     * @type {Array<string>}
     * @memberof ClimateMetrics
     */
    'features'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ConvertTokenResponse
 */
export interface ConvertTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof ConvertTokenResponse
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof ConvertTokenResponse
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof ConvertTokenResponse
     */
    'refresh_token_expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConvertTokenResponse
     */
    'access_token_expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConvertTokenResponse
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface DetailCodeResponse
 */
export interface DetailCodeResponse {
    /**
     * 
     * @type {string}
     * @memberof DetailCodeResponse
     */
    'detail': string;
    /**
     * 
     * @type {string}
     * @memberof DetailCodeResponse
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface DetailResponse
 */
export interface DetailResponse {
    /**
     * 
     * @type {string}
     * @memberof DetailResponse
     */
    'detail': string;
}
/**
 * 
 * @export
 * @interface DocumentedConvertToken
 */
export interface DocumentedConvertToken {
    /**
     * Grant type. Example=\'convert_token\'
     * @type {string}
     * @memberof DocumentedConvertToken
     */
    'grant_type': string;
    /**
     * Oauth2 backend. Example=\'google-oauth2\',\'facebook\', \'apple-id\'
     * @type {string}
     * @memberof DocumentedConvertToken
     */
    'backend': string;
    /**
     * Client id from the django oauth application. Example=\'f7XdU...\'
     * @type {string}
     * @memberof DocumentedConvertToken
     */
    'client_id': string;
    /**
     * Client secret from the django oauth application. Example=\'HsrrX...\'
     * @type {string}
     * @memberof DocumentedConvertToken
     */
    'client_secret': string;
    /**
     * Oauth2 access token. Example=\'ya29.ew...\'
     * @type {string}
     * @memberof DocumentedConvertToken
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface ExtractTextResponse
 */
export interface ExtractTextResponse {
    /**
     * Result of test extraction.
     * @type {string}
     * @memberof ExtractTextResponse
     */
    'extracted_text': string;
}
/**
 * 
 * @export
 * @interface HealthMetrics
 */
export interface HealthMetrics {
    /**
     * 
     * @type {number}
     * @memberof HealthMetrics
     */
    'additives_score': number | null;
    /**
     * 
     * @type {number}
     * @memberof HealthMetrics
     */
    'nutriscore_score': number | null;
}
/**
 * 
 * @export
 * @interface Logout
 */
export interface Logout {
    /**
     * 
     * @type {string}
     * @memberof Logout
     */
    'refresh_token': string;
}
/**
 * 
 * @export
 * @interface PackagingMetrics
 */
export interface PackagingMetrics {
    /**
     * 
     * @type {Array<string>}
     * @memberof PackagingMetrics
     */
    'features'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaginatedProduct
 */
export interface PaginatedProduct {
    /**
     * 
     * @type {number}
     * @memberof PaginatedProduct
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedProduct
     */
    'next': string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedProduct
     */
    'previous': string | null;
    /**
     * 
     * @type {Array<Product>}
     * @memberof PaginatedProduct
     */
    'results': Array<Product>;
}
/**
 * 
 * @export
 * @interface PasswordToken
 */
export interface PasswordToken {
    /**
     * 
     * @type {string}
     * @memberof PasswordToken
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordToken
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'category'?: ProductCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'quantity'?: string | null;
    /**
     * Keeps url of remote front image
     * @type {string}
     * @memberof Product
     */
    'front_image_url'?: string | null;
    /**
     * Keeps front image stored by us
     * @type {string}
     * @memberof Product
     */
    'front_image'?: string | null;
    /**
     * Keeps url of remote back image
     * @type {string}
     * @memberof Product
     */
    'back_image_url'?: string | null;
    /**
     * Keeps back image stored by us
     * @type {string}
     * @memberof Product
     */
    'back_image'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'scanning_time'?: string | null;
}

export const ProductCategoryEnum = {
    Food: 'food',
    Cosmetics: 'cosmetics',
    Tech: 'tech'
} as const;

export type ProductCategoryEnum = typeof ProductCategoryEnum[keyof typeof ProductCategoryEnum];

/**
 * 
 * @export
 * @interface ProductMetrics
 */
export interface ProductMetrics {
    /**
     * 
     * @type {HealthMetrics}
     * @memberof ProductMetrics
     */
    'health'?: HealthMetrics;
    /**
     * 
     * @type {PackagingMetrics}
     * @memberof ProductMetrics
     */
    'packaging'?: PackagingMetrics;
    /**
     * 
     * @type {ClimateMetrics}
     * @memberof ProductMetrics
     */
    'climate'?: ClimateMetrics;
}
/**
 * 
 * @export
 * @interface ProductPartialUpdate
 */
export interface ProductPartialUpdate {
    /**
     * 
     * @type {string}
     * @memberof ProductPartialUpdate
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductPartialUpdate
     */
    'quantity'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductPartialUpdate
     */
    'category'?: ProductPartialUpdateCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductPartialUpdate
     */
    'barcode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductPartialUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductPartialUpdate
     */
    'ingredients'?: string | null;
    /**
     * Keeps front image stored by us
     * @type {string}
     * @memberof ProductPartialUpdate
     */
    'front_image'?: string | null;
    /**
     * Keeps back image stored by us
     * @type {string}
     * @memberof ProductPartialUpdate
     */
    'back_image'?: string | null;
}

export const ProductPartialUpdateCategoryEnum = {
    Food: 'food',
    Cosmetics: 'cosmetics',
    Tech: 'tech'
} as const;

export type ProductPartialUpdateCategoryEnum = typeof ProductPartialUpdateCategoryEnum[keyof typeof ProductPartialUpdateCategoryEnum];

/**
 * 
 * @export
 * @interface ProductRetrieve
 */
export interface ProductRetrieve {
    /**
     * 
     * @type {number}
     * @memberof ProductRetrieve
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductRetrieve
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductRetrieve
     */
    'quantity'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductRetrieve
     */
    'category'?: ProductRetrieveCategoryEnum;
    /**
     * Keeps url of remote front image
     * @type {string}
     * @memberof ProductRetrieve
     */
    'front_image_url'?: string | null;
    /**
     * Keeps front image stored by us
     * @type {string}
     * @memberof ProductRetrieve
     */
    'front_image'?: string | null;
    /**
     * Keeps url of remote back image
     * @type {string}
     * @memberof ProductRetrieve
     */
    'back_image_url'?: string | null;
    /**
     * Keeps back image stored by us
     * @type {string}
     * @memberof ProductRetrieve
     */
    'back_image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductRetrieve
     */
    'barcode': string;
    /**
     * 
     * @type {string}
     * @memberof ProductRetrieve
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductRetrieve
     */
    'ingredients'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProductRetrieve
     */
    'score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProductRetrieve
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductRetrieve
     */
    'scanning_time'?: string | null;
    /**
     * 
     * @type {Array<ProductSection>}
     * @memberof ProductRetrieve
     */
    'sections'?: Array<ProductSection>;
    /**
     * 
     * @type {ProductMetrics}
     * @memberof ProductRetrieve
     */
    'metrics'?: ProductMetrics;
    /**
     * 
     * @type {number}
     * @memberof ProductRetrieve
     */
    'author'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProductRetrieve
     */
    'verified'?: boolean;
    /**
     * 
     * @type {Questionnaire}
     * @memberof ProductRetrieve
     */
    'active_questionnaire'?: Questionnaire;
}

export const ProductRetrieveCategoryEnum = {
    Food: 'food',
    Cosmetics: 'cosmetics',
    Tech: 'tech'
} as const;

export type ProductRetrieveCategoryEnum = typeof ProductRetrieveCategoryEnum[keyof typeof ProductRetrieveCategoryEnum];

/**
 * 
 * @export
 * @interface ProductSection
 */
export interface ProductSection {
    /**
     * 
     * @type {string}
     * @memberof ProductSection
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ProductSection
     */
    'type': string;
    /**
     * 
     * @type {number}
     * @memberof ProductSection
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof ProductSection
     */
    'color': string;
    /**
     * 
     * @type {string}
     * @memberof ProductSection
     */
    'icon_url'?: string;
}
/**
 * 
 * @export
 * @interface ProductUpdate
 */
export interface ProductUpdate {
    /**
     * 
     * @type {string}
     * @memberof ProductUpdate
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductUpdate
     */
    'quantity'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductUpdate
     */
    'category'?: ProductUpdateCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductUpdate
     */
    'barcode': string;
    /**
     * 
     * @type {string}
     * @memberof ProductUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductUpdate
     */
    'ingredients'?: string | null;
    /**
     * Keeps front image stored by us
     * @type {string}
     * @memberof ProductUpdate
     */
    'front_image'?: string | null;
    /**
     * Keeps back image stored by us
     * @type {string}
     * @memberof ProductUpdate
     */
    'back_image'?: string | null;
}

export const ProductUpdateCategoryEnum = {
    Food: 'food',
    Cosmetics: 'cosmetics',
    Tech: 'tech'
} as const;

export type ProductUpdateCategoryEnum = typeof ProductUpdateCategoryEnum[keyof typeof ProductUpdateCategoryEnum];

/**
 * 
 * @export
 * @interface Question
 */
export interface Question {
    /**
     * 
     * @type {number}
     * @memberof Question
     */
    'id'?: number;
    /**
     * 
     * @type {Array<Answer>}
     * @memberof Question
     */
    'answers': Array<Answer>;
    /**
     * 
     * @type {string}
     * @memberof Question
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Question
     */
    'type': QuestionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Question
     */
    'order'?: number;
}

export const QuestionTypeEnum = {
    Freetext: 'freetext',
    YesNo: 'yes_no',
    LikertScale: 'likert_scale'
} as const;

export type QuestionTypeEnum = typeof QuestionTypeEnum[keyof typeof QuestionTypeEnum];

/**
 * 
 * @export
 * @interface QuestionCreate
 */
export interface QuestionCreate {
    /**
     * 
     * @type {string}
     * @memberof QuestionCreate
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof QuestionCreate
     */
    'type': QuestionCreateTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof QuestionCreate
     */
    'questionnaire': number;
}

export const QuestionCreateTypeEnum = {
    Freetext: 'freetext',
    YesNo: 'yes_no',
    LikertScale: 'likert_scale'
} as const;

export type QuestionCreateTypeEnum = typeof QuestionCreateTypeEnum[keyof typeof QuestionCreateTypeEnum];

/**
 * 
 * @export
 * @interface QuestionList
 */
export interface QuestionList {
    /**
     * 
     * @type {number}
     * @memberof QuestionList
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof QuestionList
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof QuestionList
     */
    'type': QuestionListTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof QuestionList
     */
    'order'?: number;
}

export const QuestionListTypeEnum = {
    Freetext: 'freetext',
    YesNo: 'yes_no',
    LikertScale: 'likert_scale'
} as const;

export type QuestionListTypeEnum = typeof QuestionListTypeEnum[keyof typeof QuestionListTypeEnum];

/**
 * 
 * @export
 * @interface QuestionUpdate
 */
export interface QuestionUpdate {
    /**
     * 
     * @type {string}
     * @memberof QuestionUpdate
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof QuestionUpdate
     */
    'order'?: number;
}
/**
 * 
 * @export
 * @interface Questionnaire
 */
export interface Questionnaire {
    /**
     * 
     * @type {number}
     * @memberof Questionnaire
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Questionnaire
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof Questionnaire
     */
    'product': number;
    /**
     * 
     * @type {Array<Question>}
     * @memberof Questionnaire
     */
    'questions': Array<Question>;
}
/**
 * 
 * @export
 * @interface QuestionnaireCreate
 */
export interface QuestionnaireCreate {
    /**
     * 
     * @type {number}
     * @memberof QuestionnaireCreate
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireCreate
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof QuestionnaireCreate
     */
    'product': number;
}
/**
 * 
 * @export
 * @interface QuestionnaireList
 */
export interface QuestionnaireList {
    /**
     * 
     * @type {number}
     * @memberof QuestionnaireList
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireList
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof QuestionnaireList
     */
    'product': number;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireList
     */
    'status'?: QuestionnaireListStatusEnum;
}

export const QuestionnaireListStatusEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;

export type QuestionnaireListStatusEnum = typeof QuestionnaireListStatusEnum[keyof typeof QuestionnaireListStatusEnum];

/**
 * 
 * @export
 * @interface QuestionnaireUpdate
 */
export interface QuestionnaireUpdate {
    /**
     * 
     * @type {number}
     * @memberof QuestionnaireUpdate
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireUpdate
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireUpdate
     */
    'status'?: QuestionnaireUpdateStatusEnum;
}

export const QuestionnaireUpdateStatusEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;

export type QuestionnaireUpdateStatusEnum = typeof QuestionnaireUpdateStatusEnum[keyof typeof QuestionnaireUpdateStatusEnum];

/**
 * 
 * @export
 * @interface QuestionnairesAnswersList200Response
 */
export interface QuestionnairesAnswersList200Response {
    /**
     * 
     * @type {number}
     * @memberof QuestionnairesAnswersList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof QuestionnairesAnswersList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QuestionnairesAnswersList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<AnswerList>}
     * @memberof QuestionnairesAnswersList200Response
     */
    'results': Array<AnswerList>;
}
/**
 * 
 * @export
 * @interface QuestionnairesCampaignsList200Response
 */
export interface QuestionnairesCampaignsList200Response {
    /**
     * 
     * @type {number}
     * @memberof QuestionnairesCampaignsList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof QuestionnairesCampaignsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QuestionnairesCampaignsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<CampaignList>}
     * @memberof QuestionnairesCampaignsList200Response
     */
    'results': Array<CampaignList>;
}
/**
 * 
 * @export
 * @interface QuestionnairesList200Response
 */
export interface QuestionnairesList200Response {
    /**
     * 
     * @type {number}
     * @memberof QuestionnairesList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof QuestionnairesList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QuestionnairesList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<QuestionnaireList>}
     * @memberof QuestionnairesList200Response
     */
    'results': Array<QuestionnaireList>;
}
/**
 * 
 * @export
 * @interface QuestionnairesQuestionsList200Response
 */
export interface QuestionnairesQuestionsList200Response {
    /**
     * 
     * @type {number}
     * @memberof QuestionnairesQuestionsList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof QuestionnairesQuestionsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QuestionnairesQuestionsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<QuestionList>}
     * @memberof QuestionnairesQuestionsList200Response
     */
    'results': Array<QuestionList>;
}
/**
 * 
 * @export
 * @interface QuestionnairesReportsList200Response
 */
export interface QuestionnairesReportsList200Response {
    /**
     * 
     * @type {number}
     * @memberof QuestionnairesReportsList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof QuestionnairesReportsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QuestionnairesReportsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ReportList>}
     * @memberof QuestionnairesReportsList200Response
     */
    'results': Array<ReportList>;
}
/**
 * 
 * @export
 * @interface Report
 */
export interface Report {
    /**
     * 
     * @type {number}
     * @memberof Report
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof Report
     */
    'campaign': number;
    /**
     * 
     * @type {object}
     * @memberof Report
     */
    'results'?: object;
}
/**
 * 
 * @export
 * @interface ReportList
 */
export interface ReportList {
    /**
     * 
     * @type {number}
     * @memberof ReportList
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportList
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof ReportList
     */
    'campaign': number;
}
/**
 * 
 * @export
 * @interface RequestResetPasswordToken
 */
export interface RequestResetPasswordToken {
    /**
     * 
     * @type {string}
     * @memberof RequestResetPasswordToken
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ResetToken
 */
export interface ResetToken {
    /**
     * 
     * @type {string}
     * @memberof ResetToken
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface SessionLogin
 */
export interface SessionLogin {
    /**
     * 
     * @type {string}
     * @memberof SessionLogin
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof SessionLogin
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface TokenObtainPairWithExpiration
 */
export interface TokenObtainPairWithExpiration {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPairWithExpiration
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPairWithExpiration
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface TokenRefreshWithExpiration
 */
export interface TokenRefreshWithExpiration {
    /**
     * 
     * @type {string}
     * @memberof TokenRefreshWithExpiration
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof TokenRefreshWithExpiration
     */
    'access'?: string;
}
/**
 * 
 * @export
 * @interface TokenWithExpirationResponse
 */
export interface TokenWithExpirationResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenWithExpirationResponse
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof TokenWithExpirationResponse
     */
    'access'?: string;
    /**
     * 
     * @type {number}
     * @memberof TokenWithExpirationResponse
     */
    'user_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TokenWithExpirationResponse
     */
    'refresh_token_expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenWithExpirationResponse
     */
    'access_token_expires_at'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
     * @type {boolean}
     * @memberof User
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * 
     * @type {Client}
     * @memberof User
     */
    'client'?: Client;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'avatar_url'?: string;
}
/**
 * 
 * @export
 * @interface ValidationErrorsResponse
 */
export interface ValidationErrorsResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ValidationErrorsResponse
     */
    'details': { [key: string]: string; };
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {ChangePassword} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsChangePasswordPartialUpdate: async (id: number, data: ChangePassword, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsChangePasswordPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsChangePasswordPartialUpdate', 'data', data)
            const localVarPath = `/accounts/change-password/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {ChangePassword} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsChangePasswordUpdate: async (id: number, data: ChangePassword, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsChangePasswordUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsChangePasswordUpdate', 'data', data)
            const localVarPath = `/accounts/change-password/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientAvatarsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsClientAvatarsDelete', 'id', id)
            const localVarPath = `/accounts/client-avatars/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this client.
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientAvatarsPartialUpdate: async (id: number, image: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsClientAvatarsPartialUpdate', 'id', id)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('accountsClientAvatarsPartialUpdate', 'image', image)
            const localVarPath = `/accounts/client-avatars/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this client.
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientAvatarsUpdate: async (id: number, image: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsClientAvatarsUpdate', 'id', id)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('accountsClientAvatarsUpdate', 'image', image)
            const localVarPath = `/accounts/client-avatars/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {string} domain 
         * @param {string} [email] 
         * @param {File} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientsCreate: async (name: string, domain: string, email?: string, image?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('accountsClientsCreate', 'name', name)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('accountsClientsCreate', 'domain', domain)
            const localVarPath = `/accounts/clients/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (domain !== undefined) { 
                localVarFormParams.append('domain', domain as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsClientsDelete', 'id', id)
            const localVarPath = `/accounts/clients/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [perPage] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientsList: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/clients/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this client.
         * @param {string} name 
         * @param {string} domain 
         * @param {string | null} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientsPartialUpdate: async (id: number, name: string, domain: string, email?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsClientsPartialUpdate', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('accountsClientsPartialUpdate', 'name', name)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('accountsClientsPartialUpdate', 'domain', domain)
            const localVarPath = `/accounts/clients/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (domain !== undefined) { 
                localVarFormParams.append('domain', domain as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientsRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsClientsRead', 'id', id)
            const localVarPath = `/accounts/clients/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this client.
         * @param {string} name 
         * @param {string} domain 
         * @param {string | null} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientsUpdate: async (id: number, name: string, domain: string, email?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsClientsUpdate', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('accountsClientsUpdate', 'name', name)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('accountsClientsUpdate', 'domain', domain)
            const localVarPath = `/accounts/clients/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (domain !== undefined) { 
                localVarFormParams.append('domain', domain as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DocumentedConvertToken} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsConvertTokenCreate: async (data: DocumentedConvertToken, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsConvertTokenCreate', 'data', data)
            const localVarPath = `/accounts/convert-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TokenObtainPairWithExpiration} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLoginCreate: async (data: TokenObtainPairWithExpiration, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsLoginCreate', 'data', data)
            const localVarPath = `/accounts/login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Logout} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLogoutCreate: async (data: Logout, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsLogoutCreate', 'data', data)
            const localVarPath = `/accounts/logout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An Api View which provides a method to reset a password based on a unique token
         * @param {PasswordToken} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordResetConfirmCreate: async (data: PasswordToken, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsPasswordResetConfirmCreate', 'data', data)
            const localVarPath = `/accounts/password-reset/confirm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RequestResetPasswordToken} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordResetCreate: async (data: RequestResetPasswordToken, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsPasswordResetCreate', 'data', data)
            const localVarPath = `/accounts/password-reset/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects user from email to a mobile app using a custom mobile scheme
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordResetRedirectRead: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('accountsPasswordResetRedirectRead', 'token', token)
            const localVarPath = `/accounts/password-reset-redirect/{token}/`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An Api View which provides a method to verify that a token is valid
         * @param {ResetToken} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordResetValidateTokenCreate: async (data: ResetToken, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsPasswordResetValidateTokenCreate', 'data', data)
            const localVarPath = `/accounts/password-reset/validate_token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TokenRefreshWithExpiration} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRefreshTokenCreate: async (data: TokenRefreshWithExpiration, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsRefreshTokenCreate', 'data', data)
            const localVarPath = `/accounts/refresh-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SessionLogin} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsSessionLogin: async (data: SessionLogin, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsSessionLogin', 'data', data)
            const localVarPath = `/accounts/session-login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsSessionLogout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/session-logout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserAvatarsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsUserAvatarsDelete', 'id', id)
            const localVarPath = `/accounts/user-avatars/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserAvatarsPartialUpdate: async (id: number, image: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsUserAvatarsPartialUpdate', 'id', id)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('accountsUserAvatarsPartialUpdate', 'image', image)
            const localVarPath = `/accounts/user-avatars/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserAvatarsUpdate: async (id: number, image: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsUserAvatarsUpdate', 'id', id)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('accountsUserAvatarsUpdate', 'image', image)
            const localVarPath = `/accounts/user-avatars/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An Api View which provides a method to reset a password based on a unique token
         * @param {PasswordToken} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUsersActivateCreate: async (data: PasswordToken, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('accountsUsersActivateCreate', 'data', data)
            const localVarPath = `/accounts/users/activate/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {string} firstName 
         * @param {string} lastName 
         * @param {string} password 
         * @param {string} password2 
         * @param {number} [clientId] 
         * @param {File} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUsersCreate: async (email: string, firstName: string, lastName: string, password: string, password2: string, clientId?: number, image?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('accountsUsersCreate', 'email', email)
            // verify required parameter 'firstName' is not null or undefined
            assertParamExists('accountsUsersCreate', 'firstName', firstName)
            // verify required parameter 'lastName' is not null or undefined
            assertParamExists('accountsUsersCreate', 'lastName', lastName)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('accountsUsersCreate', 'password', password)
            // verify required parameter 'password2' is not null or undefined
            assertParamExists('accountsUsersCreate', 'password2', password2)
            const localVarPath = `/accounts/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.append('client_id', clientId as any);
            }
    
            if (firstName !== undefined) { 
                localVarFormParams.append('first_name', firstName as any);
            }
    
            if (lastName !== undefined) { 
                localVarFormParams.append('last_name', lastName as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.append('password', password as any);
            }
    
            if (password2 !== undefined) { 
                localVarFormParams.append('password2', password2 as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUsersDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsUsersDelete', 'id', id)
            const localVarPath = `/accounts/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {number} clientId 
         * @param {string} firstName 
         * @param {string} lastName 
         * @param {File} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUsersInviteCreate: async (email: string, clientId: number, firstName: string, lastName: string, image?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('accountsUsersInviteCreate', 'email', email)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('accountsUsersInviteCreate', 'clientId', clientId)
            // verify required parameter 'firstName' is not null or undefined
            assertParamExists('accountsUsersInviteCreate', 'firstName', firstName)
            // verify required parameter 'lastName' is not null or undefined
            assertParamExists('accountsUsersInviteCreate', 'lastName', lastName)
            const localVarPath = `/accounts/users/invite/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.append('client_id', clientId as any);
            }
    
            if (firstName !== undefined) { 
                localVarFormParams.append('first_name', firstName as any);
            }
    
            if (lastName !== undefined) { 
                localVarFormParams.append('last_name', lastName as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [perPage] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUsersList: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {string} email 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {number} [clientId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUsersPartialUpdate: async (id: number, email: string, firstName?: string, lastName?: string, clientId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsUsersPartialUpdate', 'id', id)
            // verify required parameter 'email' is not null or undefined
            assertParamExists('accountsUsersPartialUpdate', 'email', email)
            const localVarPath = `/accounts/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (firstName !== undefined) { 
                localVarFormParams.append('first_name', firstName as any);
            }
    
            if (lastName !== undefined) { 
                localVarFormParams.append('last_name', lastName as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.append('client_id', clientId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUsersRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsUsersRead', 'id', id)
            const localVarPath = `/accounts/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {string} email 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {number} [clientId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUsersUpdate: async (id: number, email: string, firstName?: string, lastName?: string, clientId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsUsersUpdate', 'id', id)
            // verify required parameter 'email' is not null or undefined
            assertParamExists('accountsUsersUpdate', 'email', email)
            const localVarPath = `/accounts/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (firstName !== undefined) { 
                localVarFormParams.append('first_name', firstName as any);
            }
    
            if (lastName !== undefined) { 
                localVarFormParams.append('last_name', lastName as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.append('client_id', clientId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCsrfToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/csrf/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {ChangePassword} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsChangePasswordPartialUpdate(id: number, data: ChangePassword, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsChangePasswordPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {ChangePassword} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsChangePasswordUpdate(id: number, data: ChangePassword, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsChangePasswordUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsClientAvatarsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsClientAvatarsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this client.
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsClientAvatarsPartialUpdate(id: number, image: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsClientAvatarsPartialUpdate(id, image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this client.
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsClientAvatarsUpdate(id: number, image: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsClientAvatarsUpdate(id, image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name 
         * @param {string} domain 
         * @param {string} [email] 
         * @param {File} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsClientsCreate(name: string, domain: string, email?: string, image?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsClientsCreate(name, domain, email, image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsClientsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsClientsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [perPage] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsClientsList(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsClientsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsClientsList(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this client.
         * @param {string} name 
         * @param {string} domain 
         * @param {string | null} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsClientsPartialUpdate(id: number, name: string, domain: string, email?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsClientsPartialUpdate(id, name, domain, email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsClientsRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsClientsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this client.
         * @param {string} name 
         * @param {string} domain 
         * @param {string | null} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsClientsUpdate(id: number, name: string, domain: string, email?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsClientsUpdate(id, name, domain, email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DocumentedConvertToken} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsConvertTokenCreate(data: DocumentedConvertToken, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConvertTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsConvertTokenCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TokenObtainPairWithExpiration} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsLoginCreate(data: TokenObtainPairWithExpiration, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenWithExpirationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsLoginCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Logout} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsLogoutCreate(data: Logout, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsLogoutCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * An Api View which provides a method to reset a password based on a unique token
         * @param {PasswordToken} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPasswordResetConfirmCreate(data: PasswordToken, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPasswordResetConfirmCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RequestResetPasswordToken} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPasswordResetCreate(data: RequestResetPasswordToken, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPasswordResetCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Redirects user from email to a mobile app using a custom mobile scheme
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPasswordResetRedirectRead(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPasswordResetRedirectRead(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * An Api View which provides a method to verify that a token is valid
         * @param {ResetToken} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPasswordResetValidateTokenCreate(data: ResetToken, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResetToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPasswordResetValidateTokenCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TokenRefreshWithExpiration} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsRefreshTokenCreate(data: TokenRefreshWithExpiration, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenWithExpirationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsRefreshTokenCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SessionLogin} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsSessionLogin(data: SessionLogin, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsSessionLogin(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsSessionLogout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsSessionLogout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUserAvatarsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUserAvatarsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUserAvatarsPartialUpdate(id: number, image: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUserAvatarsPartialUpdate(id, image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUserAvatarsUpdate(id: number, image: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUserAvatarsUpdate(id, image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * An Api View which provides a method to reset a password based on a unique token
         * @param {PasswordToken} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUsersActivateCreate(data: PasswordToken, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUsersActivateCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} email 
         * @param {string} firstName 
         * @param {string} lastName 
         * @param {string} password 
         * @param {string} password2 
         * @param {number} [clientId] 
         * @param {File} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUsersCreate(email: string, firstName: string, lastName: string, password: string, password2: string, clientId?: number, image?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUsersCreate(email, firstName, lastName, password, password2, clientId, image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUsersDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUsersDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} email 
         * @param {number} clientId 
         * @param {string} firstName 
         * @param {string} lastName 
         * @param {File} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUsersInviteCreate(email: string, clientId: number, firstName: string, lastName: string, image?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUsersInviteCreate(email, clientId, firstName, lastName, image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [perPage] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUsersList(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsUsersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUsersList(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {string} email 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {number} [clientId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUsersPartialUpdate(id: number, email: string, firstName?: string, lastName?: string, clientId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUsersPartialUpdate(id, email, firstName, lastName, clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUsersRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUsersRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {string} email 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {number} [clientId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUsersUpdate(id: number, email: string, firstName?: string, lastName?: string, clientId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUsersUpdate(id, email, firstName, lastName, clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCsrfToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCsrfToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * 
         * @param {AccountsApiAccountsChangePasswordPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsChangePasswordPartialUpdate(requestParameters: AccountsApiAccountsChangePasswordPartialUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<DetailResponse> {
            return localVarFp.accountsChangePasswordPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsChangePasswordUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsChangePasswordUpdate(requestParameters: AccountsApiAccountsChangePasswordUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<DetailResponse> {
            return localVarFp.accountsChangePasswordUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsClientAvatarsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientAvatarsDelete(requestParameters: AccountsApiAccountsClientAvatarsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.accountsClientAvatarsDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsClientAvatarsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientAvatarsPartialUpdate(requestParameters: AccountsApiAccountsClientAvatarsPartialUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Client> {
            return localVarFp.accountsClientAvatarsPartialUpdate(requestParameters.id, requestParameters.image, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsClientAvatarsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientAvatarsUpdate(requestParameters: AccountsApiAccountsClientAvatarsUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Client> {
            return localVarFp.accountsClientAvatarsUpdate(requestParameters.id, requestParameters.image, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsClientsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientsCreate(requestParameters: AccountsApiAccountsClientsCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Client> {
            return localVarFp.accountsClientsCreate(requestParameters.name, requestParameters.domain, requestParameters.email, requestParameters.image, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsClientsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientsDelete(requestParameters: AccountsApiAccountsClientsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountsClientsDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsClientsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientsList(requestParameters: AccountsApiAccountsClientsListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<AccountsClientsList200Response> {
            return localVarFp.accountsClientsList(requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsClientsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientsPartialUpdate(requestParameters: AccountsApiAccountsClientsPartialUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Client> {
            return localVarFp.accountsClientsPartialUpdate(requestParameters.id, requestParameters.name, requestParameters.domain, requestParameters.email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsClientsReadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientsRead(requestParameters: AccountsApiAccountsClientsReadRequest, options?: AxiosRequestConfig): AxiosPromise<Client> {
            return localVarFp.accountsClientsRead(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsClientsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClientsUpdate(requestParameters: AccountsApiAccountsClientsUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Client> {
            return localVarFp.accountsClientsUpdate(requestParameters.id, requestParameters.name, requestParameters.domain, requestParameters.email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsConvertTokenCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsConvertTokenCreate(requestParameters: AccountsApiAccountsConvertTokenCreateRequest, options?: AxiosRequestConfig): AxiosPromise<ConvertTokenResponse> {
            return localVarFp.accountsConvertTokenCreate(requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsLoginCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLoginCreate(requestParameters: AccountsApiAccountsLoginCreateRequest, options?: AxiosRequestConfig): AxiosPromise<TokenWithExpirationResponse> {
            return localVarFp.accountsLoginCreate(requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsLogoutCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLogoutCreate(requestParameters: AccountsApiAccountsLogoutCreateRequest, options?: AxiosRequestConfig): AxiosPromise<DetailResponse> {
            return localVarFp.accountsLogoutCreate(requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * An Api View which provides a method to reset a password based on a unique token
         * @param {AccountsApiAccountsPasswordResetConfirmCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordResetConfirmCreate(requestParameters: AccountsApiAccountsPasswordResetConfirmCreateRequest, options?: AxiosRequestConfig): AxiosPromise<PasswordToken> {
            return localVarFp.accountsPasswordResetConfirmCreate(requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsPasswordResetCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordResetCreate(requestParameters: AccountsApiAccountsPasswordResetCreateRequest, options?: AxiosRequestConfig): AxiosPromise<DetailResponse> {
            return localVarFp.accountsPasswordResetCreate(requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * Redirects user from email to a mobile app using a custom mobile scheme
         * @param {AccountsApiAccountsPasswordResetRedirectReadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordResetRedirectRead(requestParameters: AccountsApiAccountsPasswordResetRedirectReadRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.accountsPasswordResetRedirectRead(requestParameters.token, options).then((request) => request(axios, basePath));
        },
        /**
         * An Api View which provides a method to verify that a token is valid
         * @param {AccountsApiAccountsPasswordResetValidateTokenCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordResetValidateTokenCreate(requestParameters: AccountsApiAccountsPasswordResetValidateTokenCreateRequest, options?: AxiosRequestConfig): AxiosPromise<ResetToken> {
            return localVarFp.accountsPasswordResetValidateTokenCreate(requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsRefreshTokenCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRefreshTokenCreate(requestParameters: AccountsApiAccountsRefreshTokenCreateRequest, options?: AxiosRequestConfig): AxiosPromise<TokenWithExpirationResponse> {
            return localVarFp.accountsRefreshTokenCreate(requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsSessionLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsSessionLogin(requestParameters: AccountsApiAccountsSessionLoginRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.accountsSessionLogin(requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsSessionLogout(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountsSessionLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsUserAvatarsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserAvatarsDelete(requestParameters: AccountsApiAccountsUserAvatarsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.accountsUserAvatarsDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsUserAvatarsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserAvatarsPartialUpdate(requestParameters: AccountsApiAccountsUserAvatarsPartialUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.accountsUserAvatarsPartialUpdate(requestParameters.id, requestParameters.image, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsUserAvatarsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserAvatarsUpdate(requestParameters: AccountsApiAccountsUserAvatarsUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.accountsUserAvatarsUpdate(requestParameters.id, requestParameters.image, options).then((request) => request(axios, basePath));
        },
        /**
         * An Api View which provides a method to reset a password based on a unique token
         * @param {AccountsApiAccountsUsersActivateCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUsersActivateCreate(requestParameters: AccountsApiAccountsUsersActivateCreateRequest, options?: AxiosRequestConfig): AxiosPromise<PasswordToken> {
            return localVarFp.accountsUsersActivateCreate(requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsUsersCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUsersCreate(requestParameters: AccountsApiAccountsUsersCreateRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.accountsUsersCreate(requestParameters.email, requestParameters.firstName, requestParameters.lastName, requestParameters.password, requestParameters.password2, requestParameters.clientId, requestParameters.image, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsUsersDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUsersDelete(requestParameters: AccountsApiAccountsUsersDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountsUsersDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsUsersInviteCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUsersInviteCreate(requestParameters: AccountsApiAccountsUsersInviteCreateRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.accountsUsersInviteCreate(requestParameters.email, requestParameters.clientId, requestParameters.firstName, requestParameters.lastName, requestParameters.image, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsUsersListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUsersList(requestParameters: AccountsApiAccountsUsersListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<AccountsUsersList200Response> {
            return localVarFp.accountsUsersList(requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsUsersPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUsersPartialUpdate(requestParameters: AccountsApiAccountsUsersPartialUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.accountsUsersPartialUpdate(requestParameters.id, requestParameters.email, requestParameters.firstName, requestParameters.lastName, requestParameters.clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsUsersReadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUsersRead(requestParameters: AccountsApiAccountsUsersReadRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.accountsUsersRead(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiAccountsUsersUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUsersUpdate(requestParameters: AccountsApiAccountsUsersUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.accountsUsersUpdate(requestParameters.id, requestParameters.email, requestParameters.firstName, requestParameters.lastName, requestParameters.clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCsrfToken(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getCsrfToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for accountsChangePasswordPartialUpdate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsChangePasswordPartialUpdateRequest
 */
export interface AccountsApiAccountsChangePasswordPartialUpdateRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof AccountsApiAccountsChangePasswordPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ChangePassword}
     * @memberof AccountsApiAccountsChangePasswordPartialUpdate
     */
    readonly data: ChangePassword
}

/**
 * Request parameters for accountsChangePasswordUpdate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsChangePasswordUpdateRequest
 */
export interface AccountsApiAccountsChangePasswordUpdateRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof AccountsApiAccountsChangePasswordUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ChangePassword}
     * @memberof AccountsApiAccountsChangePasswordUpdate
     */
    readonly data: ChangePassword
}

/**
 * Request parameters for accountsClientAvatarsDelete operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsClientAvatarsDeleteRequest
 */
export interface AccountsApiAccountsClientAvatarsDeleteRequest {
    /**
     * A unique integer value identifying this client.
     * @type {number}
     * @memberof AccountsApiAccountsClientAvatarsDelete
     */
    readonly id: number
}

/**
 * Request parameters for accountsClientAvatarsPartialUpdate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsClientAvatarsPartialUpdateRequest
 */
export interface AccountsApiAccountsClientAvatarsPartialUpdateRequest {
    /**
     * A unique integer value identifying this client.
     * @type {number}
     * @memberof AccountsApiAccountsClientAvatarsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {File}
     * @memberof AccountsApiAccountsClientAvatarsPartialUpdate
     */
    readonly image: File
}

/**
 * Request parameters for accountsClientAvatarsUpdate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsClientAvatarsUpdateRequest
 */
export interface AccountsApiAccountsClientAvatarsUpdateRequest {
    /**
     * A unique integer value identifying this client.
     * @type {number}
     * @memberof AccountsApiAccountsClientAvatarsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {File}
     * @memberof AccountsApiAccountsClientAvatarsUpdate
     */
    readonly image: File
}

/**
 * Request parameters for accountsClientsCreate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsClientsCreateRequest
 */
export interface AccountsApiAccountsClientsCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsClientsCreate
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsClientsCreate
     */
    readonly domain: string

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsClientsCreate
     */
    readonly email?: string

    /**
     * 
     * @type {File}
     * @memberof AccountsApiAccountsClientsCreate
     */
    readonly image?: File
}

/**
 * Request parameters for accountsClientsDelete operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsClientsDeleteRequest
 */
export interface AccountsApiAccountsClientsDeleteRequest {
    /**
     * A unique integer value identifying this client.
     * @type {number}
     * @memberof AccountsApiAccountsClientsDelete
     */
    readonly id: number
}

/**
 * Request parameters for accountsClientsList operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsClientsListRequest
 */
export interface AccountsApiAccountsClientsListRequest {
    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof AccountsApiAccountsClientsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof AccountsApiAccountsClientsList
     */
    readonly perPage?: number
}

/**
 * Request parameters for accountsClientsPartialUpdate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsClientsPartialUpdateRequest
 */
export interface AccountsApiAccountsClientsPartialUpdateRequest {
    /**
     * A unique integer value identifying this client.
     * @type {number}
     * @memberof AccountsApiAccountsClientsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsClientsPartialUpdate
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsClientsPartialUpdate
     */
    readonly domain: string

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsClientsPartialUpdate
     */
    readonly email?: string | null
}

/**
 * Request parameters for accountsClientsRead operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsClientsReadRequest
 */
export interface AccountsApiAccountsClientsReadRequest {
    /**
     * A unique integer value identifying this client.
     * @type {number}
     * @memberof AccountsApiAccountsClientsRead
     */
    readonly id: number
}

/**
 * Request parameters for accountsClientsUpdate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsClientsUpdateRequest
 */
export interface AccountsApiAccountsClientsUpdateRequest {
    /**
     * A unique integer value identifying this client.
     * @type {number}
     * @memberof AccountsApiAccountsClientsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsClientsUpdate
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsClientsUpdate
     */
    readonly domain: string

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsClientsUpdate
     */
    readonly email?: string | null
}

/**
 * Request parameters for accountsConvertTokenCreate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsConvertTokenCreateRequest
 */
export interface AccountsApiAccountsConvertTokenCreateRequest {
    /**
     * 
     * @type {DocumentedConvertToken}
     * @memberof AccountsApiAccountsConvertTokenCreate
     */
    readonly data: DocumentedConvertToken
}

/**
 * Request parameters for accountsLoginCreate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsLoginCreateRequest
 */
export interface AccountsApiAccountsLoginCreateRequest {
    /**
     * 
     * @type {TokenObtainPairWithExpiration}
     * @memberof AccountsApiAccountsLoginCreate
     */
    readonly data: TokenObtainPairWithExpiration
}

/**
 * Request parameters for accountsLogoutCreate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsLogoutCreateRequest
 */
export interface AccountsApiAccountsLogoutCreateRequest {
    /**
     * 
     * @type {Logout}
     * @memberof AccountsApiAccountsLogoutCreate
     */
    readonly data: Logout
}

/**
 * Request parameters for accountsPasswordResetConfirmCreate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsPasswordResetConfirmCreateRequest
 */
export interface AccountsApiAccountsPasswordResetConfirmCreateRequest {
    /**
     * 
     * @type {PasswordToken}
     * @memberof AccountsApiAccountsPasswordResetConfirmCreate
     */
    readonly data: PasswordToken
}

/**
 * Request parameters for accountsPasswordResetCreate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsPasswordResetCreateRequest
 */
export interface AccountsApiAccountsPasswordResetCreateRequest {
    /**
     * 
     * @type {RequestResetPasswordToken}
     * @memberof AccountsApiAccountsPasswordResetCreate
     */
    readonly data: RequestResetPasswordToken
}

/**
 * Request parameters for accountsPasswordResetRedirectRead operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsPasswordResetRedirectReadRequest
 */
export interface AccountsApiAccountsPasswordResetRedirectReadRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsPasswordResetRedirectRead
     */
    readonly token: string
}

/**
 * Request parameters for accountsPasswordResetValidateTokenCreate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsPasswordResetValidateTokenCreateRequest
 */
export interface AccountsApiAccountsPasswordResetValidateTokenCreateRequest {
    /**
     * 
     * @type {ResetToken}
     * @memberof AccountsApiAccountsPasswordResetValidateTokenCreate
     */
    readonly data: ResetToken
}

/**
 * Request parameters for accountsRefreshTokenCreate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsRefreshTokenCreateRequest
 */
export interface AccountsApiAccountsRefreshTokenCreateRequest {
    /**
     * 
     * @type {TokenRefreshWithExpiration}
     * @memberof AccountsApiAccountsRefreshTokenCreate
     */
    readonly data: TokenRefreshWithExpiration
}

/**
 * Request parameters for accountsSessionLogin operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsSessionLoginRequest
 */
export interface AccountsApiAccountsSessionLoginRequest {
    /**
     * 
     * @type {SessionLogin}
     * @memberof AccountsApiAccountsSessionLogin
     */
    readonly data: SessionLogin
}

/**
 * Request parameters for accountsUserAvatarsDelete operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsUserAvatarsDeleteRequest
 */
export interface AccountsApiAccountsUserAvatarsDeleteRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof AccountsApiAccountsUserAvatarsDelete
     */
    readonly id: number
}

/**
 * Request parameters for accountsUserAvatarsPartialUpdate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsUserAvatarsPartialUpdateRequest
 */
export interface AccountsApiAccountsUserAvatarsPartialUpdateRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof AccountsApiAccountsUserAvatarsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {File}
     * @memberof AccountsApiAccountsUserAvatarsPartialUpdate
     */
    readonly image: File
}

/**
 * Request parameters for accountsUserAvatarsUpdate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsUserAvatarsUpdateRequest
 */
export interface AccountsApiAccountsUserAvatarsUpdateRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof AccountsApiAccountsUserAvatarsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {File}
     * @memberof AccountsApiAccountsUserAvatarsUpdate
     */
    readonly image: File
}

/**
 * Request parameters for accountsUsersActivateCreate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsUsersActivateCreateRequest
 */
export interface AccountsApiAccountsUsersActivateCreateRequest {
    /**
     * 
     * @type {PasswordToken}
     * @memberof AccountsApiAccountsUsersActivateCreate
     */
    readonly data: PasswordToken
}

/**
 * Request parameters for accountsUsersCreate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsUsersCreateRequest
 */
export interface AccountsApiAccountsUsersCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsUsersCreate
     */
    readonly email: string

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsUsersCreate
     */
    readonly firstName: string

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsUsersCreate
     */
    readonly lastName: string

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsUsersCreate
     */
    readonly password: string

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsUsersCreate
     */
    readonly password2: string

    /**
     * 
     * @type {number}
     * @memberof AccountsApiAccountsUsersCreate
     */
    readonly clientId?: number

    /**
     * 
     * @type {File}
     * @memberof AccountsApiAccountsUsersCreate
     */
    readonly image?: File
}

/**
 * Request parameters for accountsUsersDelete operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsUsersDeleteRequest
 */
export interface AccountsApiAccountsUsersDeleteRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof AccountsApiAccountsUsersDelete
     */
    readonly id: number
}

/**
 * Request parameters for accountsUsersInviteCreate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsUsersInviteCreateRequest
 */
export interface AccountsApiAccountsUsersInviteCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsUsersInviteCreate
     */
    readonly email: string

    /**
     * 
     * @type {number}
     * @memberof AccountsApiAccountsUsersInviteCreate
     */
    readonly clientId: number

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsUsersInviteCreate
     */
    readonly firstName: string

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsUsersInviteCreate
     */
    readonly lastName: string

    /**
     * 
     * @type {File}
     * @memberof AccountsApiAccountsUsersInviteCreate
     */
    readonly image?: File
}

/**
 * Request parameters for accountsUsersList operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsUsersListRequest
 */
export interface AccountsApiAccountsUsersListRequest {
    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof AccountsApiAccountsUsersList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof AccountsApiAccountsUsersList
     */
    readonly perPage?: number
}

/**
 * Request parameters for accountsUsersPartialUpdate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsUsersPartialUpdateRequest
 */
export interface AccountsApiAccountsUsersPartialUpdateRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof AccountsApiAccountsUsersPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsUsersPartialUpdate
     */
    readonly email: string

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsUsersPartialUpdate
     */
    readonly firstName?: string

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsUsersPartialUpdate
     */
    readonly lastName?: string

    /**
     * 
     * @type {number}
     * @memberof AccountsApiAccountsUsersPartialUpdate
     */
    readonly clientId?: number
}

/**
 * Request parameters for accountsUsersRead operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsUsersReadRequest
 */
export interface AccountsApiAccountsUsersReadRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof AccountsApiAccountsUsersRead
     */
    readonly id: number
}

/**
 * Request parameters for accountsUsersUpdate operation in AccountsApi.
 * @export
 * @interface AccountsApiAccountsUsersUpdateRequest
 */
export interface AccountsApiAccountsUsersUpdateRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof AccountsApiAccountsUsersUpdate
     */
    readonly id: number

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsUsersUpdate
     */
    readonly email: string

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsUsersUpdate
     */
    readonly firstName?: string

    /**
     * 
     * @type {string}
     * @memberof AccountsApiAccountsUsersUpdate
     */
    readonly lastName?: string

    /**
     * 
     * @type {number}
     * @memberof AccountsApiAccountsUsersUpdate
     */
    readonly clientId?: number
}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * 
     * @param {AccountsApiAccountsChangePasswordPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsChangePasswordPartialUpdate(requestParameters: AccountsApiAccountsChangePasswordPartialUpdateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsChangePasswordPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsChangePasswordUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsChangePasswordUpdate(requestParameters: AccountsApiAccountsChangePasswordUpdateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsChangePasswordUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsClientAvatarsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsClientAvatarsDelete(requestParameters: AccountsApiAccountsClientAvatarsDeleteRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsClientAvatarsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsClientAvatarsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsClientAvatarsPartialUpdate(requestParameters: AccountsApiAccountsClientAvatarsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsClientAvatarsPartialUpdate(requestParameters.id, requestParameters.image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsClientAvatarsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsClientAvatarsUpdate(requestParameters: AccountsApiAccountsClientAvatarsUpdateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsClientAvatarsUpdate(requestParameters.id, requestParameters.image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsClientsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsClientsCreate(requestParameters: AccountsApiAccountsClientsCreateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsClientsCreate(requestParameters.name, requestParameters.domain, requestParameters.email, requestParameters.image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsClientsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsClientsDelete(requestParameters: AccountsApiAccountsClientsDeleteRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsClientsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsClientsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsClientsList(requestParameters: AccountsApiAccountsClientsListRequest = {}, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsClientsList(requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsClientsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsClientsPartialUpdate(requestParameters: AccountsApiAccountsClientsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsClientsPartialUpdate(requestParameters.id, requestParameters.name, requestParameters.domain, requestParameters.email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsClientsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsClientsRead(requestParameters: AccountsApiAccountsClientsReadRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsClientsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsClientsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsClientsUpdate(requestParameters: AccountsApiAccountsClientsUpdateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsClientsUpdate(requestParameters.id, requestParameters.name, requestParameters.domain, requestParameters.email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsConvertTokenCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsConvertTokenCreate(requestParameters: AccountsApiAccountsConvertTokenCreateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsConvertTokenCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsLoginCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsLoginCreate(requestParameters: AccountsApiAccountsLoginCreateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsLoginCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsLogoutCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsLogoutCreate(requestParameters: AccountsApiAccountsLogoutCreateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsLogoutCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * An Api View which provides a method to reset a password based on a unique token
     * @param {AccountsApiAccountsPasswordResetConfirmCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsPasswordResetConfirmCreate(requestParameters: AccountsApiAccountsPasswordResetConfirmCreateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsPasswordResetConfirmCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsPasswordResetCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsPasswordResetCreate(requestParameters: AccountsApiAccountsPasswordResetCreateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsPasswordResetCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Redirects user from email to a mobile app using a custom mobile scheme
     * @param {AccountsApiAccountsPasswordResetRedirectReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsPasswordResetRedirectRead(requestParameters: AccountsApiAccountsPasswordResetRedirectReadRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsPasswordResetRedirectRead(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * An Api View which provides a method to verify that a token is valid
     * @param {AccountsApiAccountsPasswordResetValidateTokenCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsPasswordResetValidateTokenCreate(requestParameters: AccountsApiAccountsPasswordResetValidateTokenCreateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsPasswordResetValidateTokenCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsRefreshTokenCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsRefreshTokenCreate(requestParameters: AccountsApiAccountsRefreshTokenCreateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsRefreshTokenCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsSessionLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsSessionLogin(requestParameters: AccountsApiAccountsSessionLoginRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsSessionLogin(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsSessionLogout(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsSessionLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsUserAvatarsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUserAvatarsDelete(requestParameters: AccountsApiAccountsUserAvatarsDeleteRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUserAvatarsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsUserAvatarsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUserAvatarsPartialUpdate(requestParameters: AccountsApiAccountsUserAvatarsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUserAvatarsPartialUpdate(requestParameters.id, requestParameters.image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsUserAvatarsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUserAvatarsUpdate(requestParameters: AccountsApiAccountsUserAvatarsUpdateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUserAvatarsUpdate(requestParameters.id, requestParameters.image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * An Api View which provides a method to reset a password based on a unique token
     * @param {AccountsApiAccountsUsersActivateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUsersActivateCreate(requestParameters: AccountsApiAccountsUsersActivateCreateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUsersActivateCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsUsersCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUsersCreate(requestParameters: AccountsApiAccountsUsersCreateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUsersCreate(requestParameters.email, requestParameters.firstName, requestParameters.lastName, requestParameters.password, requestParameters.password2, requestParameters.clientId, requestParameters.image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsUsersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUsersDelete(requestParameters: AccountsApiAccountsUsersDeleteRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUsersDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsUsersInviteCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUsersInviteCreate(requestParameters: AccountsApiAccountsUsersInviteCreateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUsersInviteCreate(requestParameters.email, requestParameters.clientId, requestParameters.firstName, requestParameters.lastName, requestParameters.image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsUsersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUsersList(requestParameters: AccountsApiAccountsUsersListRequest = {}, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUsersList(requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsUsersPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUsersPartialUpdate(requestParameters: AccountsApiAccountsUsersPartialUpdateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUsersPartialUpdate(requestParameters.id, requestParameters.email, requestParameters.firstName, requestParameters.lastName, requestParameters.clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsUsersReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUsersRead(requestParameters: AccountsApiAccountsUsersReadRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUsersRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiAccountsUsersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUsersUpdate(requestParameters: AccountsApiAccountsUsersUpdateRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUsersUpdate(requestParameters.id, requestParameters.email, requestParameters.firstName, requestParameters.lastName, requestParameters.clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getCsrfToken(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getCsrfToken(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The endpoint is used in the following flows:  * Authorization code * Client credentials
         * @summary Implements an endpoint to convert a provider token to an access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authConvertTokenCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/convert-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An endpoint for disconnect social auth backend providers such as Facebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDisconnectBackendCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/disconnect-backend/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidate all refresh tokens associated with a client id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authInvalidateRefreshTokensCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/invalidate-refresh-tokens/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all access tokens associated with a client id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authInvalidateSessionsCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/invalidate-sessions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Implements an endpoint to revoke access or refresh tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRevokeTokenCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/revoke-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint is used in the following flows:  * Authorization code * Password * Client credentials
         * @summary Implements an endpoint to provide access tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * The endpoint is used in the following flows:  * Authorization code * Client credentials
         * @summary Implements an endpoint to convert a provider token to an access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authConvertTokenCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authConvertTokenCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * An endpoint for disconnect social auth backend providers such as Facebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDisconnectBackendCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDisconnectBackendCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Invalidate all refresh tokens associated with a client id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authInvalidateRefreshTokensCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authInvalidateRefreshTokensCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete all access tokens associated with a client id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authInvalidateSessionsCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authInvalidateSessionsCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Implements an endpoint to revoke access or refresh tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRevokeTokenCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRevokeTokenCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The endpoint is used in the following flows:  * Authorization code * Password * Client credentials
         * @summary Implements an endpoint to provide access tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * The endpoint is used in the following flows:  * Authorization code * Client credentials
         * @summary Implements an endpoint to convert a provider token to an access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authConvertTokenCreate(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authConvertTokenCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * An endpoint for disconnect social auth backend providers such as Facebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDisconnectBackendCreate(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authDisconnectBackendCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Invalidate all refresh tokens associated with a client id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authInvalidateRefreshTokensCreate(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authInvalidateRefreshTokensCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all access tokens associated with a client id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authInvalidateSessionsCreate(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authInvalidateSessionsCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Implements an endpoint to revoke access or refresh tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRevokeTokenCreate(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authRevokeTokenCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint is used in the following flows:  * Authorization code * Password * Client credentials
         * @summary Implements an endpoint to provide access tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenCreate(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authTokenCreate(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * The endpoint is used in the following flows:  * Authorization code * Client credentials
     * @summary Implements an endpoint to convert a provider token to an access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authConvertTokenCreate(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authConvertTokenCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * An endpoint for disconnect social auth backend providers such as Facebook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authDisconnectBackendCreate(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authDisconnectBackendCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalidate all refresh tokens associated with a client id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authInvalidateRefreshTokensCreate(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authInvalidateRefreshTokensCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all access tokens associated with a client id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authInvalidateSessionsCreate(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authInvalidateSessionsCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Implements an endpoint to revoke access or refresh tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRevokeTokenCreate(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRevokeTokenCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint is used in the following flows:  * Authorization code * Password * Client credentials
     * @summary Implements an endpoint to provide access tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenCreate(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenCreate(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} barcode 
         * @param {string | null} [name] 
         * @param {string | null} [quantity] 
         * @param {ProductsCreateCategoryEnum} [category] 
         * @param {string | null} [description] 
         * @param {string | null} [ingredients] 
         * @param {File | null} [frontImage] Keeps front image stored by us
         * @param {File | null} [backImage] Keeps back image stored by us
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsCreate: async (barcode: string, name?: string | null, quantity?: string | null, category?: ProductsCreateCategoryEnum, description?: string | null, ingredients?: string | null, frontImage?: File | null, backImage?: File | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'barcode' is not null or undefined
            assertParamExists('productsCreate', 'barcode', barcode)
            const localVarPath = `/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.append('quantity', quantity as any);
            }
    
            if (category !== undefined) { 
                localVarFormParams.append('category', category as any);
            }
    
            if (barcode !== undefined) { 
                localVarFormParams.append('barcode', barcode as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (ingredients !== undefined) { 
                localVarFormParams.append('ingredients', ingredients as any);
            }
    
            if (frontImage !== undefined) { 
                localVarFormParams.append('front_image', frontImage as any);
            }
    
            if (backImage !== undefined) { 
                localVarFormParams.append('back_image', backImage as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [search] A search term.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [perPage] Number of results to return per page.
         * @param {boolean} [onlyUserProducts] Filter only user\&#39;s saved products
         * @param {any} [scanningTimeLt] Filter products scanned before the passed datetime (Available only with \&#39;only_user_products&#x3D;true\&#39;)
         * @param {boolean} [authored] Filter products added by the requesting user
         * @param {boolean} [verified] Filter products by the user who created a product (Available only with \&#39;authored&#x3D;true\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsList: async (search?: string, ordering?: string, page?: number, perPage?: number, onlyUserProducts?: boolean, scanningTimeLt?: any, authored?: boolean, verified?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (onlyUserProducts !== undefined) {
                localVarQueryParameter['only_user_products'] = onlyUserProducts;
            }

            if (scanningTimeLt !== undefined) {
                localVarQueryParameter['scanning_time_lt'] = scanningTimeLt;
            }

            if (authored !== undefined) {
                localVarQueryParameter['authored'] = authored;
            }

            if (verified !== undefined) {
                localVarQueryParameter['verified'] = verified;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string | null} [name] 
         * @param {string | null} [quantity] 
         * @param {ProductsPartialUpdateCategoryEnum} [category] 
         * @param {string} [barcode] 
         * @param {string | null} [description] 
         * @param {string | null} [ingredients] 
         * @param {File | null} [frontImage] Keeps front image stored by us
         * @param {File | null} [backImage] Keeps back image stored by us
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPartialUpdate: async (id: string, name?: string | null, quantity?: string | null, category?: ProductsPartialUpdateCategoryEnum, barcode?: string, description?: string | null, ingredients?: string | null, frontImage?: File | null, backImage?: File | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsPartialUpdate', 'id', id)
            const localVarPath = `/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.append('quantity', quantity as any);
            }
    
            if (category !== undefined) { 
                localVarFormParams.append('category', category as any);
            }
    
            if (barcode !== undefined) { 
                localVarFormParams.append('barcode', barcode as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (ingredients !== undefined) { 
                localVarFormParams.append('ingredients', ingredients as any);
            }
    
            if (frontImage !== undefined) { 
                localVarFormParams.append('front_image', frontImage as any);
            }
    
            if (backImage !== undefined) { 
                localVarFormParams.append('back_image', backImage as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} [textImage] Image with text to extract
         * @param {string} [textType] Type of text to extract. Currently available: \\\&#39;ingredients\\\&#39;, \\\&#39;description\\\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPost: async (textImage?: File, textType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/extract-text/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (textImage !== undefined) { 
                localVarFormParams.append('text_image', textImage as any);
            }
    
            if (textType !== undefined) { 
                localVarFormParams.append('text_type', textType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows to retrieve a product info from OpenFoodFacts API by barcode.
         * @param {string} barcode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsProductByBarcodeRead: async (barcode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'barcode' is not null or undefined
            assertParamExists('productsProductByBarcodeRead', 'barcode', barcode)
            const localVarPath = `/products/product-by-barcode/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (barcode !== undefined) {
                localVarQueryParameter['barcode'] = barcode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsRead: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsRead', 'id', id)
            const localVarPath = `/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} barcode 
         * @param {string | null} [name] 
         * @param {string | null} [quantity] 
         * @param {ProductsUpdateCategoryEnum} [category] 
         * @param {string | null} [description] 
         * @param {string | null} [ingredients] 
         * @param {File | null} [frontImage] Keeps front image stored by us
         * @param {File | null} [backImage] Keeps back image stored by us
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsUpdate: async (id: string, barcode: string, name?: string | null, quantity?: string | null, category?: ProductsUpdateCategoryEnum, description?: string | null, ingredients?: string | null, frontImage?: File | null, backImage?: File | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsUpdate', 'id', id)
            // verify required parameter 'barcode' is not null or undefined
            assertParamExists('productsUpdate', 'barcode', barcode)
            const localVarPath = `/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (quantity !== undefined) { 
                localVarFormParams.append('quantity', quantity as any);
            }
    
            if (category !== undefined) { 
                localVarFormParams.append('category', category as any);
            }
    
            if (barcode !== undefined) { 
                localVarFormParams.append('barcode', barcode as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (ingredients !== undefined) { 
                localVarFormParams.append('ingredients', ingredients as any);
            }
    
            if (frontImage !== undefined) { 
                localVarFormParams.append('front_image', frontImage as any);
            }
    
            if (backImage !== undefined) { 
                localVarFormParams.append('back_image', backImage as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} barcode 
         * @param {string | null} [name] 
         * @param {string | null} [quantity] 
         * @param {ProductsCreateCategoryEnum} [category] 
         * @param {string | null} [description] 
         * @param {string | null} [ingredients] 
         * @param {File | null} [frontImage] Keeps front image stored by us
         * @param {File | null} [backImage] Keeps back image stored by us
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsCreate(barcode: string, name?: string | null, quantity?: string | null, category?: ProductsCreateCategoryEnum, description?: string | null, ingredients?: string | null, frontImage?: File | null, backImage?: File | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsCreate(barcode, name, quantity, category, description, ingredients, frontImage, backImage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [search] A search term.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [perPage] Number of results to return per page.
         * @param {boolean} [onlyUserProducts] Filter only user\&#39;s saved products
         * @param {any} [scanningTimeLt] Filter products scanned before the passed datetime (Available only with \&#39;only_user_products&#x3D;true\&#39;)
         * @param {boolean} [authored] Filter products added by the requesting user
         * @param {boolean} [verified] Filter products by the user who created a product (Available only with \&#39;authored&#x3D;true\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsList(search?: string, ordering?: string, page?: number, perPage?: number, onlyUserProducts?: boolean, scanningTimeLt?: any, authored?: boolean, verified?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsList(search, ordering, page, perPage, onlyUserProducts, scanningTimeLt, authored, verified, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string | null} [name] 
         * @param {string | null} [quantity] 
         * @param {ProductsPartialUpdateCategoryEnum} [category] 
         * @param {string} [barcode] 
         * @param {string | null} [description] 
         * @param {string | null} [ingredients] 
         * @param {File | null} [frontImage] Keeps front image stored by us
         * @param {File | null} [backImage] Keeps back image stored by us
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsPartialUpdate(id: string, name?: string | null, quantity?: string | null, category?: ProductsPartialUpdateCategoryEnum, barcode?: string, description?: string | null, ingredients?: string | null, frontImage?: File | null, backImage?: File | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductPartialUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsPartialUpdate(id, name, quantity, category, barcode, description, ingredients, frontImage, backImage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {File} [textImage] Image with text to extract
         * @param {string} [textType] Type of text to extract. Currently available: \\\&#39;ingredients\\\&#39;, \\\&#39;description\\\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsPost(textImage?: File, textType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtractTextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsPost(textImage, textType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoint that allows to retrieve a product info from OpenFoodFacts API by barcode.
         * @param {string} barcode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsProductByBarcodeRead(barcode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductRetrieve>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsProductByBarcodeRead(barcode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsRead(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductRetrieve>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} barcode 
         * @param {string | null} [name] 
         * @param {string | null} [quantity] 
         * @param {ProductsUpdateCategoryEnum} [category] 
         * @param {string | null} [description] 
         * @param {string | null} [ingredients] 
         * @param {File | null} [frontImage] Keeps front image stored by us
         * @param {File | null} [backImage] Keeps back image stored by us
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsUpdate(id: string, barcode: string, name?: string | null, quantity?: string | null, category?: ProductsUpdateCategoryEnum, description?: string | null, ingredients?: string | null, frontImage?: File | null, backImage?: File | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsUpdate(id, barcode, name, quantity, category, description, ingredients, frontImage, backImage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * 
         * @param {ProductsApiProductsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsCreate(requestParameters: ProductsApiProductsCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.productsCreate(requestParameters.barcode, requestParameters.name, requestParameters.quantity, requestParameters.category, requestParameters.description, requestParameters.ingredients, requestParameters.frontImage, requestParameters.backImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ProductsApiProductsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsList(requestParameters: ProductsApiProductsListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PaginatedProduct> {
            return localVarFp.productsList(requestParameters.search, requestParameters.ordering, requestParameters.page, requestParameters.perPage, requestParameters.onlyUserProducts, requestParameters.scanningTimeLt, requestParameters.authored, requestParameters.verified, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ProductsApiProductsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPartialUpdate(requestParameters: ProductsApiProductsPartialUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<ProductPartialUpdate> {
            return localVarFp.productsPartialUpdate(requestParameters.id, requestParameters.name, requestParameters.quantity, requestParameters.category, requestParameters.barcode, requestParameters.description, requestParameters.ingredients, requestParameters.frontImage, requestParameters.backImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ProductsApiProductsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPost(requestParameters: ProductsApiProductsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ExtractTextResponse> {
            return localVarFp.productsPost(requestParameters.textImage, requestParameters.textType, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows to retrieve a product info from OpenFoodFacts API by barcode.
         * @param {ProductsApiProductsProductByBarcodeReadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsProductByBarcodeRead(requestParameters: ProductsApiProductsProductByBarcodeReadRequest, options?: AxiosRequestConfig): AxiosPromise<ProductRetrieve> {
            return localVarFp.productsProductByBarcodeRead(requestParameters.barcode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ProductsApiProductsReadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsRead(requestParameters: ProductsApiProductsReadRequest, options?: AxiosRequestConfig): AxiosPromise<ProductRetrieve> {
            return localVarFp.productsRead(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ProductsApiProductsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsUpdate(requestParameters: ProductsApiProductsUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<ProductUpdate> {
            return localVarFp.productsUpdate(requestParameters.id, requestParameters.barcode, requestParameters.name, requestParameters.quantity, requestParameters.category, requestParameters.description, requestParameters.ingredients, requestParameters.frontImage, requestParameters.backImage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for productsCreate operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsCreateRequest
 */
export interface ProductsApiProductsCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsCreate
     */
    readonly barcode: string

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsCreate
     */
    readonly name?: string | null

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsCreate
     */
    readonly quantity?: string | null

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsCreate
     */
    readonly category?: ProductsCreateCategoryEnum

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsCreate
     */
    readonly description?: string | null

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsCreate
     */
    readonly ingredients?: string | null

    /**
     * Keeps front image stored by us
     * @type {File}
     * @memberof ProductsApiProductsCreate
     */
    readonly frontImage?: File | null

    /**
     * Keeps back image stored by us
     * @type {File}
     * @memberof ProductsApiProductsCreate
     */
    readonly backImage?: File | null
}

/**
 * Request parameters for productsList operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsListRequest
 */
export interface ProductsApiProductsListRequest {
    /**
     * A search term.
     * @type {string}
     * @memberof ProductsApiProductsList
     */
    readonly search?: string

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof ProductsApiProductsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof ProductsApiProductsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ProductsApiProductsList
     */
    readonly perPage?: number

    /**
     * Filter only user\&#39;s saved products
     * @type {boolean}
     * @memberof ProductsApiProductsList
     */
    readonly onlyUserProducts?: boolean

    /**
     * Filter products scanned before the passed datetime (Available only with \&#39;only_user_products&#x3D;true\&#39;)
     * @type {any}
     * @memberof ProductsApiProductsList
     */
    readonly scanningTimeLt?: any

    /**
     * Filter products added by the requesting user
     * @type {boolean}
     * @memberof ProductsApiProductsList
     */
    readonly authored?: boolean

    /**
     * Filter products by the user who created a product (Available only with \&#39;authored&#x3D;true\&#39;)
     * @type {boolean}
     * @memberof ProductsApiProductsList
     */
    readonly verified?: boolean
}

/**
 * Request parameters for productsPartialUpdate operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsPartialUpdateRequest
 */
export interface ProductsApiProductsPartialUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsPartialUpdate
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsPartialUpdate
     */
    readonly name?: string | null

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsPartialUpdate
     */
    readonly quantity?: string | null

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsPartialUpdate
     */
    readonly category?: ProductsPartialUpdateCategoryEnum

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsPartialUpdate
     */
    readonly barcode?: string

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsPartialUpdate
     */
    readonly description?: string | null

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsPartialUpdate
     */
    readonly ingredients?: string | null

    /**
     * Keeps front image stored by us
     * @type {File}
     * @memberof ProductsApiProductsPartialUpdate
     */
    readonly frontImage?: File | null

    /**
     * Keeps back image stored by us
     * @type {File}
     * @memberof ProductsApiProductsPartialUpdate
     */
    readonly backImage?: File | null
}

/**
 * Request parameters for productsPost operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsPostRequest
 */
export interface ProductsApiProductsPostRequest {
    /**
     * Image with text to extract
     * @type {File}
     * @memberof ProductsApiProductsPost
     */
    readonly textImage?: File

    /**
     * Type of text to extract. Currently available: \\\&#39;ingredients\\\&#39;, \\\&#39;description\\\&#39;
     * @type {string}
     * @memberof ProductsApiProductsPost
     */
    readonly textType?: string
}

/**
 * Request parameters for productsProductByBarcodeRead operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsProductByBarcodeReadRequest
 */
export interface ProductsApiProductsProductByBarcodeReadRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsProductByBarcodeRead
     */
    readonly barcode: string
}

/**
 * Request parameters for productsRead operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsReadRequest
 */
export interface ProductsApiProductsReadRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsRead
     */
    readonly id: string
}

/**
 * Request parameters for productsUpdate operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsUpdateRequest
 */
export interface ProductsApiProductsUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsUpdate
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsUpdate
     */
    readonly barcode: string

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsUpdate
     */
    readonly name?: string | null

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsUpdate
     */
    readonly quantity?: string | null

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsUpdate
     */
    readonly category?: ProductsUpdateCategoryEnum

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsUpdate
     */
    readonly description?: string | null

    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsUpdate
     */
    readonly ingredients?: string | null

    /**
     * Keeps front image stored by us
     * @type {File}
     * @memberof ProductsApiProductsUpdate
     */
    readonly frontImage?: File | null

    /**
     * Keeps back image stored by us
     * @type {File}
     * @memberof ProductsApiProductsUpdate
     */
    readonly backImage?: File | null
}

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * 
     * @param {ProductsApiProductsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsCreate(requestParameters: ProductsApiProductsCreateRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsCreate(requestParameters.barcode, requestParameters.name, requestParameters.quantity, requestParameters.category, requestParameters.description, requestParameters.ingredients, requestParameters.frontImage, requestParameters.backImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProductsApiProductsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsList(requestParameters: ProductsApiProductsListRequest = {}, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsList(requestParameters.search, requestParameters.ordering, requestParameters.page, requestParameters.perPage, requestParameters.onlyUserProducts, requestParameters.scanningTimeLt, requestParameters.authored, requestParameters.verified, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProductsApiProductsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsPartialUpdate(requestParameters: ProductsApiProductsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsPartialUpdate(requestParameters.id, requestParameters.name, requestParameters.quantity, requestParameters.category, requestParameters.barcode, requestParameters.description, requestParameters.ingredients, requestParameters.frontImage, requestParameters.backImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProductsApiProductsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsPost(requestParameters: ProductsApiProductsPostRequest = {}, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsPost(requestParameters.textImage, requestParameters.textType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows to retrieve a product info from OpenFoodFacts API by barcode.
     * @param {ProductsApiProductsProductByBarcodeReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsProductByBarcodeRead(requestParameters: ProductsApiProductsProductByBarcodeReadRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsProductByBarcodeRead(requestParameters.barcode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProductsApiProductsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsRead(requestParameters: ProductsApiProductsReadRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProductsApiProductsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsUpdate(requestParameters: ProductsApiProductsUpdateRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsUpdate(requestParameters.id, requestParameters.barcode, requestParameters.name, requestParameters.quantity, requestParameters.category, requestParameters.description, requestParameters.ingredients, requestParameters.frontImage, requestParameters.backImage, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ProductsCreateCategoryEnum = {
    Food: 'food',
    Cosmetics: 'cosmetics',
    Tech: 'tech'
} as const;
export type ProductsCreateCategoryEnum = typeof ProductsCreateCategoryEnum[keyof typeof ProductsCreateCategoryEnum];
/**
 * @export
 */
export const ProductsPartialUpdateCategoryEnum = {
    Food: 'food',
    Cosmetics: 'cosmetics',
    Tech: 'tech'
} as const;
export type ProductsPartialUpdateCategoryEnum = typeof ProductsPartialUpdateCategoryEnum[keyof typeof ProductsPartialUpdateCategoryEnum];
/**
 * @export
 */
export const ProductsUpdateCategoryEnum = {
    Food: 'food',
    Cosmetics: 'cosmetics',
    Tech: 'tech'
} as const;
export type ProductsUpdateCategoryEnum = typeof ProductsUpdateCategoryEnum[keyof typeof ProductsUpdateCategoryEnum];


/**
 * QuestionnairesApi - axios parameter creator
 * @export
 */
export const QuestionnairesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AnswerCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesAnswersCreate: async (data: AnswerCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('questionnairesAnswersCreate', 'data', data)
            const localVarPath = `/questionnaires/answers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this answer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesAnswersDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesAnswersDelete', 'id', id)
            const localVarPath = `/questionnaires/answers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [perPage] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesAnswersList: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/questionnaires/answers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this answer.
         * @param {AnswerUpdate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesAnswersPartialUpdate: async (id: number, data: AnswerUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesAnswersPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('questionnairesAnswersPartialUpdate', 'data', data)
            const localVarPath = `/questionnaires/answers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this answer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesAnswersRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesAnswersRead', 'id', id)
            const localVarPath = `/questionnaires/answers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AnswerResponds} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesAnswersRespondUpdate: async (data: AnswerResponds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('questionnairesAnswersRespondUpdate', 'data', data)
            const localVarPath = `/questionnaires/answers/respond/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this answer.
         * @param {AnswerUpdate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesAnswersUpdate: async (id: number, data: AnswerUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesAnswersUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('questionnairesAnswersUpdate', 'data', data)
            const localVarPath = `/questionnaires/answers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CampaignCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesCampaignsCreate: async (data: CampaignCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('questionnairesCampaignsCreate', 'data', data)
            const localVarPath = `/questionnaires/campaigns/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesCampaignsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesCampaignsDelete', 'id', id)
            const localVarPath = `/questionnaires/campaigns/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [perPage] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesCampaignsList: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/questionnaires/campaigns/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {CampaignUpdate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesCampaignsPartialUpdate: async (id: number, data: CampaignUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesCampaignsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('questionnairesCampaignsPartialUpdate', 'data', data)
            const localVarPath = `/questionnaires/campaigns/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesCampaignsRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesCampaignsRead', 'id', id)
            const localVarPath = `/questionnaires/campaigns/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {CampaignUpdate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesCampaignsUpdate: async (id: number, data: CampaignUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesCampaignsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('questionnairesCampaignsUpdate', 'data', data)
            const localVarPath = `/questionnaires/campaigns/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QuestionnaireCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesCreate: async (data: QuestionnaireCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('questionnairesCreate', 'data', data)
            const localVarPath = `/questionnaires/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this questionnaire.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesDelete', 'id', id)
            const localVarPath = `/questionnaires/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [product] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [perPage] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesList: async (product?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/questionnaires/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (product !== undefined) {
                localVarQueryParameter['product'] = product;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this questionnaire.
         * @param {QuestionnaireUpdate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesPartialUpdate: async (id: number, data: QuestionnaireUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('questionnairesPartialUpdate', 'data', data)
            const localVarPath = `/questionnaires/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QuestionCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesQuestionsCreate: async (data: QuestionCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('questionnairesQuestionsCreate', 'data', data)
            const localVarPath = `/questionnaires/questions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this question.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesQuestionsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesQuestionsDelete', 'id', id)
            const localVarPath = `/questionnaires/questions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [perPage] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesQuestionsList: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/questionnaires/questions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this question.
         * @param {QuestionUpdate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesQuestionsPartialUpdate: async (id: number, data: QuestionUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesQuestionsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('questionnairesQuestionsPartialUpdate', 'data', data)
            const localVarPath = `/questionnaires/questions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this question.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesQuestionsRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesQuestionsRead', 'id', id)
            const localVarPath = `/questionnaires/questions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this question.
         * @param {QuestionUpdate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesQuestionsUpdate: async (id: number, data: QuestionUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesQuestionsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('questionnairesQuestionsUpdate', 'data', data)
            const localVarPath = `/questionnaires/questions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this questionnaire.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesRead', 'id', id)
            const localVarPath = `/questionnaires/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [perPage] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesReportsList: async (page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/questionnaires/reports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesReportsRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesReportsRead', 'id', id)
            const localVarPath = `/questionnaires/reports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this questionnaire.
         * @param {QuestionnaireUpdate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesUpdate: async (id: number, data: QuestionnaireUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('questionnairesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('questionnairesUpdate', 'data', data)
            const localVarPath = `/questionnaires/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Barrier required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestionnairesApi - functional programming interface
 * @export
 */
export const QuestionnairesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuestionnairesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AnswerCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesAnswersCreate(data: AnswerCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Answer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesAnswersCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this answer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesAnswersDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesAnswersDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [perPage] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesAnswersList(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionnairesAnswersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesAnswersList(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this answer.
         * @param {AnswerUpdate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesAnswersPartialUpdate(id: number, data: AnswerUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Answer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesAnswersPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this answer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesAnswersRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Answer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesAnswersRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AnswerResponds} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesAnswersRespondUpdate(data: AnswerResponds, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesAnswersRespondUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this answer.
         * @param {AnswerUpdate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesAnswersUpdate(id: number, data: AnswerUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Answer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesAnswersUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CampaignCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesCampaignsCreate(data: CampaignCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesCampaignsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesCampaignsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesCampaignsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [perPage] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesCampaignsList(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionnairesCampaignsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesCampaignsList(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {CampaignUpdate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesCampaignsPartialUpdate(id: number, data: CampaignUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesCampaignsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesCampaignsRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesCampaignsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {CampaignUpdate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesCampaignsUpdate(id: number, data: CampaignUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesCampaignsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {QuestionnaireCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesCreate(data: QuestionnaireCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Questionnaire>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this questionnaire.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [product] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [perPage] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesList(product?: string, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionnairesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesList(product, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this questionnaire.
         * @param {QuestionnaireUpdate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesPartialUpdate(id: number, data: QuestionnaireUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Questionnaire>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {QuestionCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesQuestionsCreate(data: QuestionCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Question>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesQuestionsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this question.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesQuestionsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesQuestionsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [perPage] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesQuestionsList(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionnairesQuestionsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesQuestionsList(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this question.
         * @param {QuestionUpdate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesQuestionsPartialUpdate(id: number, data: QuestionUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Question>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesQuestionsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this question.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesQuestionsRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Question>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesQuestionsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this question.
         * @param {QuestionUpdate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesQuestionsUpdate(id: number, data: QuestionUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Question>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesQuestionsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this questionnaire.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Questionnaire>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [perPage] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesReportsList(page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionnairesReportsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesReportsList(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesReportsRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesReportsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this questionnaire.
         * @param {QuestionnaireUpdate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionnairesUpdate(id: number, data: QuestionnaireUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Questionnaire>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionnairesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QuestionnairesApi - factory interface
 * @export
 */
export const QuestionnairesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuestionnairesApiFp(configuration)
    return {
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesAnswersCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesAnswersCreate(requestParameters: QuestionnairesApiQuestionnairesAnswersCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Answer> {
            return localVarFp.questionnairesAnswersCreate(requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesAnswersDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesAnswersDelete(requestParameters: QuestionnairesApiQuestionnairesAnswersDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.questionnairesAnswersDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesAnswersListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesAnswersList(requestParameters: QuestionnairesApiQuestionnairesAnswersListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<QuestionnairesAnswersList200Response> {
            return localVarFp.questionnairesAnswersList(requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesAnswersPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesAnswersPartialUpdate(requestParameters: QuestionnairesApiQuestionnairesAnswersPartialUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Answer> {
            return localVarFp.questionnairesAnswersPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesAnswersReadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesAnswersRead(requestParameters: QuestionnairesApiQuestionnairesAnswersReadRequest, options?: AxiosRequestConfig): AxiosPromise<Answer> {
            return localVarFp.questionnairesAnswersRead(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesAnswersRespondUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesAnswersRespondUpdate(requestParameters: QuestionnairesApiQuestionnairesAnswersRespondUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.questionnairesAnswersRespondUpdate(requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesAnswersUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesAnswersUpdate(requestParameters: QuestionnairesApiQuestionnairesAnswersUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Answer> {
            return localVarFp.questionnairesAnswersUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesCampaignsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesCampaignsCreate(requestParameters: QuestionnairesApiQuestionnairesCampaignsCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Campaign> {
            return localVarFp.questionnairesCampaignsCreate(requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesCampaignsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesCampaignsDelete(requestParameters: QuestionnairesApiQuestionnairesCampaignsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.questionnairesCampaignsDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesCampaignsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesCampaignsList(requestParameters: QuestionnairesApiQuestionnairesCampaignsListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<QuestionnairesCampaignsList200Response> {
            return localVarFp.questionnairesCampaignsList(requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesCampaignsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesCampaignsPartialUpdate(requestParameters: QuestionnairesApiQuestionnairesCampaignsPartialUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Campaign> {
            return localVarFp.questionnairesCampaignsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesCampaignsReadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesCampaignsRead(requestParameters: QuestionnairesApiQuestionnairesCampaignsReadRequest, options?: AxiosRequestConfig): AxiosPromise<Campaign> {
            return localVarFp.questionnairesCampaignsRead(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesCampaignsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesCampaignsUpdate(requestParameters: QuestionnairesApiQuestionnairesCampaignsUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Campaign> {
            return localVarFp.questionnairesCampaignsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesCreate(requestParameters: QuestionnairesApiQuestionnairesCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Questionnaire> {
            return localVarFp.questionnairesCreate(requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesDelete(requestParameters: QuestionnairesApiQuestionnairesDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.questionnairesDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesList(requestParameters: QuestionnairesApiQuestionnairesListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<QuestionnairesList200Response> {
            return localVarFp.questionnairesList(requestParameters.product, requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesPartialUpdate(requestParameters: QuestionnairesApiQuestionnairesPartialUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Questionnaire> {
            return localVarFp.questionnairesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesQuestionsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesQuestionsCreate(requestParameters: QuestionnairesApiQuestionnairesQuestionsCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Question> {
            return localVarFp.questionnairesQuestionsCreate(requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesQuestionsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesQuestionsDelete(requestParameters: QuestionnairesApiQuestionnairesQuestionsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.questionnairesQuestionsDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesQuestionsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesQuestionsList(requestParameters: QuestionnairesApiQuestionnairesQuestionsListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<QuestionnairesQuestionsList200Response> {
            return localVarFp.questionnairesQuestionsList(requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesQuestionsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesQuestionsPartialUpdate(requestParameters: QuestionnairesApiQuestionnairesQuestionsPartialUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Question> {
            return localVarFp.questionnairesQuestionsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesQuestionsReadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesQuestionsRead(requestParameters: QuestionnairesApiQuestionnairesQuestionsReadRequest, options?: AxiosRequestConfig): AxiosPromise<Question> {
            return localVarFp.questionnairesQuestionsRead(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesQuestionsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesQuestionsUpdate(requestParameters: QuestionnairesApiQuestionnairesQuestionsUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Question> {
            return localVarFp.questionnairesQuestionsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesReadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesRead(requestParameters: QuestionnairesApiQuestionnairesReadRequest, options?: AxiosRequestConfig): AxiosPromise<Questionnaire> {
            return localVarFp.questionnairesRead(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesReportsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesReportsList(requestParameters: QuestionnairesApiQuestionnairesReportsListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<QuestionnairesReportsList200Response> {
            return localVarFp.questionnairesReportsList(requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesReportsReadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesReportsRead(requestParameters: QuestionnairesApiQuestionnairesReportsReadRequest, options?: AxiosRequestConfig): AxiosPromise<Report> {
            return localVarFp.questionnairesReportsRead(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnairesApiQuestionnairesUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionnairesUpdate(requestParameters: QuestionnairesApiQuestionnairesUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Questionnaire> {
            return localVarFp.questionnairesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for questionnairesAnswersCreate operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesAnswersCreateRequest
 */
export interface QuestionnairesApiQuestionnairesAnswersCreateRequest {
    /**
     * 
     * @type {AnswerCreate}
     * @memberof QuestionnairesApiQuestionnairesAnswersCreate
     */
    readonly data: AnswerCreate
}

/**
 * Request parameters for questionnairesAnswersDelete operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesAnswersDeleteRequest
 */
export interface QuestionnairesApiQuestionnairesAnswersDeleteRequest {
    /**
     * A unique integer value identifying this answer.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesAnswersDelete
     */
    readonly id: number
}

/**
 * Request parameters for questionnairesAnswersList operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesAnswersListRequest
 */
export interface QuestionnairesApiQuestionnairesAnswersListRequest {
    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesAnswersList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesAnswersList
     */
    readonly perPage?: number
}

/**
 * Request parameters for questionnairesAnswersPartialUpdate operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesAnswersPartialUpdateRequest
 */
export interface QuestionnairesApiQuestionnairesAnswersPartialUpdateRequest {
    /**
     * A unique integer value identifying this answer.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesAnswersPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {AnswerUpdate}
     * @memberof QuestionnairesApiQuestionnairesAnswersPartialUpdate
     */
    readonly data: AnswerUpdate
}

/**
 * Request parameters for questionnairesAnswersRead operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesAnswersReadRequest
 */
export interface QuestionnairesApiQuestionnairesAnswersReadRequest {
    /**
     * A unique integer value identifying this answer.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesAnswersRead
     */
    readonly id: number
}

/**
 * Request parameters for questionnairesAnswersRespondUpdate operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesAnswersRespondUpdateRequest
 */
export interface QuestionnairesApiQuestionnairesAnswersRespondUpdateRequest {
    /**
     * 
     * @type {AnswerResponds}
     * @memberof QuestionnairesApiQuestionnairesAnswersRespondUpdate
     */
    readonly data: AnswerResponds
}

/**
 * Request parameters for questionnairesAnswersUpdate operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesAnswersUpdateRequest
 */
export interface QuestionnairesApiQuestionnairesAnswersUpdateRequest {
    /**
     * A unique integer value identifying this answer.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesAnswersUpdate
     */
    readonly id: number

    /**
     * 
     * @type {AnswerUpdate}
     * @memberof QuestionnairesApiQuestionnairesAnswersUpdate
     */
    readonly data: AnswerUpdate
}

/**
 * Request parameters for questionnairesCampaignsCreate operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesCampaignsCreateRequest
 */
export interface QuestionnairesApiQuestionnairesCampaignsCreateRequest {
    /**
     * 
     * @type {CampaignCreate}
     * @memberof QuestionnairesApiQuestionnairesCampaignsCreate
     */
    readonly data: CampaignCreate
}

/**
 * Request parameters for questionnairesCampaignsDelete operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesCampaignsDeleteRequest
 */
export interface QuestionnairesApiQuestionnairesCampaignsDeleteRequest {
    /**
     * A unique integer value identifying this campaign.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesCampaignsDelete
     */
    readonly id: number
}

/**
 * Request parameters for questionnairesCampaignsList operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesCampaignsListRequest
 */
export interface QuestionnairesApiQuestionnairesCampaignsListRequest {
    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesCampaignsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesCampaignsList
     */
    readonly perPage?: number
}

/**
 * Request parameters for questionnairesCampaignsPartialUpdate operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesCampaignsPartialUpdateRequest
 */
export interface QuestionnairesApiQuestionnairesCampaignsPartialUpdateRequest {
    /**
     * A unique integer value identifying this campaign.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesCampaignsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {CampaignUpdate}
     * @memberof QuestionnairesApiQuestionnairesCampaignsPartialUpdate
     */
    readonly data: CampaignUpdate
}

/**
 * Request parameters for questionnairesCampaignsRead operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesCampaignsReadRequest
 */
export interface QuestionnairesApiQuestionnairesCampaignsReadRequest {
    /**
     * A unique integer value identifying this campaign.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesCampaignsRead
     */
    readonly id: number
}

/**
 * Request parameters for questionnairesCampaignsUpdate operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesCampaignsUpdateRequest
 */
export interface QuestionnairesApiQuestionnairesCampaignsUpdateRequest {
    /**
     * A unique integer value identifying this campaign.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesCampaignsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {CampaignUpdate}
     * @memberof QuestionnairesApiQuestionnairesCampaignsUpdate
     */
    readonly data: CampaignUpdate
}

/**
 * Request parameters for questionnairesCreate operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesCreateRequest
 */
export interface QuestionnairesApiQuestionnairesCreateRequest {
    /**
     * 
     * @type {QuestionnaireCreate}
     * @memberof QuestionnairesApiQuestionnairesCreate
     */
    readonly data: QuestionnaireCreate
}

/**
 * Request parameters for questionnairesDelete operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesDeleteRequest
 */
export interface QuestionnairesApiQuestionnairesDeleteRequest {
    /**
     * A unique integer value identifying this questionnaire.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesDelete
     */
    readonly id: number
}

/**
 * Request parameters for questionnairesList operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesListRequest
 */
export interface QuestionnairesApiQuestionnairesListRequest {
    /**
     * 
     * @type {string}
     * @memberof QuestionnairesApiQuestionnairesList
     */
    readonly product?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesList
     */
    readonly perPage?: number
}

/**
 * Request parameters for questionnairesPartialUpdate operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesPartialUpdateRequest
 */
export interface QuestionnairesApiQuestionnairesPartialUpdateRequest {
    /**
     * A unique integer value identifying this questionnaire.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {QuestionnaireUpdate}
     * @memberof QuestionnairesApiQuestionnairesPartialUpdate
     */
    readonly data: QuestionnaireUpdate
}

/**
 * Request parameters for questionnairesQuestionsCreate operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesQuestionsCreateRequest
 */
export interface QuestionnairesApiQuestionnairesQuestionsCreateRequest {
    /**
     * 
     * @type {QuestionCreate}
     * @memberof QuestionnairesApiQuestionnairesQuestionsCreate
     */
    readonly data: QuestionCreate
}

/**
 * Request parameters for questionnairesQuestionsDelete operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesQuestionsDeleteRequest
 */
export interface QuestionnairesApiQuestionnairesQuestionsDeleteRequest {
    /**
     * A unique integer value identifying this question.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesQuestionsDelete
     */
    readonly id: number
}

/**
 * Request parameters for questionnairesQuestionsList operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesQuestionsListRequest
 */
export interface QuestionnairesApiQuestionnairesQuestionsListRequest {
    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesQuestionsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesQuestionsList
     */
    readonly perPage?: number
}

/**
 * Request parameters for questionnairesQuestionsPartialUpdate operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesQuestionsPartialUpdateRequest
 */
export interface QuestionnairesApiQuestionnairesQuestionsPartialUpdateRequest {
    /**
     * A unique integer value identifying this question.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesQuestionsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {QuestionUpdate}
     * @memberof QuestionnairesApiQuestionnairesQuestionsPartialUpdate
     */
    readonly data: QuestionUpdate
}

/**
 * Request parameters for questionnairesQuestionsRead operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesQuestionsReadRequest
 */
export interface QuestionnairesApiQuestionnairesQuestionsReadRequest {
    /**
     * A unique integer value identifying this question.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesQuestionsRead
     */
    readonly id: number
}

/**
 * Request parameters for questionnairesQuestionsUpdate operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesQuestionsUpdateRequest
 */
export interface QuestionnairesApiQuestionnairesQuestionsUpdateRequest {
    /**
     * A unique integer value identifying this question.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesQuestionsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {QuestionUpdate}
     * @memberof QuestionnairesApiQuestionnairesQuestionsUpdate
     */
    readonly data: QuestionUpdate
}

/**
 * Request parameters for questionnairesRead operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesReadRequest
 */
export interface QuestionnairesApiQuestionnairesReadRequest {
    /**
     * A unique integer value identifying this questionnaire.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesRead
     */
    readonly id: number
}

/**
 * Request parameters for questionnairesReportsList operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesReportsListRequest
 */
export interface QuestionnairesApiQuestionnairesReportsListRequest {
    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesReportsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesReportsList
     */
    readonly perPage?: number
}

/**
 * Request parameters for questionnairesReportsRead operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesReportsReadRequest
 */
export interface QuestionnairesApiQuestionnairesReportsReadRequest {
    /**
     * A unique integer value identifying this report.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesReportsRead
     */
    readonly id: number
}

/**
 * Request parameters for questionnairesUpdate operation in QuestionnairesApi.
 * @export
 * @interface QuestionnairesApiQuestionnairesUpdateRequest
 */
export interface QuestionnairesApiQuestionnairesUpdateRequest {
    /**
     * A unique integer value identifying this questionnaire.
     * @type {number}
     * @memberof QuestionnairesApiQuestionnairesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {QuestionnaireUpdate}
     * @memberof QuestionnairesApiQuestionnairesUpdate
     */
    readonly data: QuestionnaireUpdate
}

/**
 * QuestionnairesApi - object-oriented interface
 * @export
 * @class QuestionnairesApi
 * @extends {BaseAPI}
 */
export class QuestionnairesApi extends BaseAPI {
    /**
     * 
     * @param {QuestionnairesApiQuestionnairesAnswersCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesAnswersCreate(requestParameters: QuestionnairesApiQuestionnairesAnswersCreateRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesAnswersCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesAnswersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesAnswersDelete(requestParameters: QuestionnairesApiQuestionnairesAnswersDeleteRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesAnswersDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesAnswersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesAnswersList(requestParameters: QuestionnairesApiQuestionnairesAnswersListRequest = {}, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesAnswersList(requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesAnswersPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesAnswersPartialUpdate(requestParameters: QuestionnairesApiQuestionnairesAnswersPartialUpdateRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesAnswersPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesAnswersReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesAnswersRead(requestParameters: QuestionnairesApiQuestionnairesAnswersReadRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesAnswersRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesAnswersRespondUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesAnswersRespondUpdate(requestParameters: QuestionnairesApiQuestionnairesAnswersRespondUpdateRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesAnswersRespondUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesAnswersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesAnswersUpdate(requestParameters: QuestionnairesApiQuestionnairesAnswersUpdateRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesAnswersUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesCampaignsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesCampaignsCreate(requestParameters: QuestionnairesApiQuestionnairesCampaignsCreateRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesCampaignsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesCampaignsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesCampaignsDelete(requestParameters: QuestionnairesApiQuestionnairesCampaignsDeleteRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesCampaignsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesCampaignsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesCampaignsList(requestParameters: QuestionnairesApiQuestionnairesCampaignsListRequest = {}, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesCampaignsList(requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesCampaignsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesCampaignsPartialUpdate(requestParameters: QuestionnairesApiQuestionnairesCampaignsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesCampaignsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesCampaignsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesCampaignsRead(requestParameters: QuestionnairesApiQuestionnairesCampaignsReadRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesCampaignsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesCampaignsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesCampaignsUpdate(requestParameters: QuestionnairesApiQuestionnairesCampaignsUpdateRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesCampaignsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesCreate(requestParameters: QuestionnairesApiQuestionnairesCreateRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesDelete(requestParameters: QuestionnairesApiQuestionnairesDeleteRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesList(requestParameters: QuestionnairesApiQuestionnairesListRequest = {}, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesList(requestParameters.product, requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesPartialUpdate(requestParameters: QuestionnairesApiQuestionnairesPartialUpdateRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesQuestionsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesQuestionsCreate(requestParameters: QuestionnairesApiQuestionnairesQuestionsCreateRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesQuestionsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesQuestionsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesQuestionsDelete(requestParameters: QuestionnairesApiQuestionnairesQuestionsDeleteRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesQuestionsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesQuestionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesQuestionsList(requestParameters: QuestionnairesApiQuestionnairesQuestionsListRequest = {}, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesQuestionsList(requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesQuestionsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesQuestionsPartialUpdate(requestParameters: QuestionnairesApiQuestionnairesQuestionsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesQuestionsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesQuestionsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesQuestionsRead(requestParameters: QuestionnairesApiQuestionnairesQuestionsReadRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesQuestionsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesQuestionsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesQuestionsUpdate(requestParameters: QuestionnairesApiQuestionnairesQuestionsUpdateRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesQuestionsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesRead(requestParameters: QuestionnairesApiQuestionnairesReadRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesReportsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesReportsList(requestParameters: QuestionnairesApiQuestionnairesReportsListRequest = {}, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesReportsList(requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesReportsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesReportsRead(requestParameters: QuestionnairesApiQuestionnairesReportsReadRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesReportsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnairesApiQuestionnairesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionnairesApi
     */
    public questionnairesUpdate(requestParameters: QuestionnairesApiQuestionnairesUpdateRequest, options?: AxiosRequestConfig) {
        return QuestionnairesApiFp(this.configuration).questionnairesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}



